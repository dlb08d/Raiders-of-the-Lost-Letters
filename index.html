
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Raiders of the Lost Letters</title>
<style>
  :root{
    --bg:#f4e2c2; --ink:#3b2a14; --accent:#d4af37; --panel:#f7e8c7;
    --border:#8b4513; --trail:#7a4f21; --x:#a66a2a; --good:#1f8b45; --bad:#c0392b;
  }
  *{box-sizing:border-box}
  html,body{ height:100%; }
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    -webkit-tap-highlight-color: transparent;
  }
  header{ padding:14px 12px 6px; text-align:center; }
  h1{ margin:0 0 4px; color:var(--border); text-shadow:1px 1px #fff; font-size:22px; }
  .tag{ color:#6b5432; font-size:14px }
  .wrap{ width:min(980px, 94%); margin:0 auto 16px; }

  .grid{ display:grid; gap:10px; }
  .panel{ background:var(--panel); border:2px solid var(--border); border-radius:14px; padding:12px; }

  textarea{
    width:100%; min-height:120px; resize:vertical;
    border:2px solid var(--border); border-radius:10px; padding:10px;
    font-size:16px; background:#fffdf5; color:#2a1d0e; /* >=16px to prevent iOS zoom */
  }
  .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  button{
    padding:12px 14px; border:none; border-radius:12px; background:var(--accent); color:#1f1408;
    cursor:pointer; font-size:16px; min-height:44px; /* Apple HIG hit target */
  }
  button.secondary{ background:#caa33a }
  input[type="text"]{
    flex:1; padding:12px 12px; border:2px solid var(--border); border-radius:12px; font-size:18px; background:#fffdf5;
    min-height:44px;
  }
  .answer-row{ display:flex; gap:10px; align-items:center; }
  .stats{ display:flex; flex-wrap:wrap; gap:8px; font-size:13px; color:#5a4123; }
  .pill{ padding:6px 10px; background:#f9edcf; border:1px solid #d2b473; border-radius:999px; }

  /* Treasure map */
  .map-box{
    position:relative; width:100%; height:260px;
    background:linear-gradient(180deg,#e8d3a1,#d6b97b);
    border:3px solid var(--border); border-radius:16px; overflow:hidden;
  }

  /* Auto-detect: phone/tablet/desktop -> tweak map height */
  @media (max-width:430px){
    .map-box{ height:300px; }
    h1{ font-size:20px; text-shadow:none; }
    .controls button{ flex:1 1 48%; } /* two-up buttons on phone */
  }
  @media (min-width:900px){
    .map-box{ height:260px; }
  }

  /* Layer ordering */
  svg#map{ position:absolute; inset:0; z-index:2; }
  #decorLayer{ position:absolute; inset:0; pointer-events:none; z-index:3; } /* landmarks alongside trail */
  #xLayer{ position:absolute; inset:0; pointer-events:none; z-index:4; }     /* X marks */
  #avatar, #chest{ position:absolute; transform:translate(-50%,-50%); z-index:5; }

  #trail{ stroke:var(--trail); stroke-width:9; fill:none; stroke-linecap:round; stroke-dasharray:16 18; }

  .x{ position:absolute; width:14px; height:14px; transform:translate(-50%,-50%) rotate(45deg); }
  .x:before,.x:after{ content:""; position:absolute; left:50%; top:50%; width:2px; height:16px; background:var(--x);
                       transform:translate(-50%,-50%) rotate(45deg) }
  .x:after{ transform:translate(-50%,-50%) rotate(-45deg) }

  #avatar{ width:72px; height:72px; filter:drop-shadow(0 6px 6px rgba(0,0,0,.25)); }
  #chest{ width:80px; height:80px; filter:drop-shadow(0 6px 6px rgba(0,0,0,.25)); }

  /* Confetti */
  .confetti{ position:fixed; inset:0; pointer-events:none; z-index:9999; }
  .confetti i{ position:absolute; width:10px; height:10px; background:gold; opacity:0; animation:fall 1.4s ease forwards; }
  @keyframes fall{
    0%{opacity:1; transform:translateY(-20px) rotate(0)}
    100%{opacity:0; transform:translateY(120vh) rotate(720deg)}
  }

  /* Chest sparkle animation */
  #sparkles { position:absolute; inset:0; pointer-events:none; z-index:6; }
  .sparkle {
    position:absolute; width:12px; height:12px;
    background:radial-gradient(circle at 50% 50%, #fff 0%, #ffe380 40%, rgba(255,211,67,.0) 70%);
    border-radius:50%; opacity:0;
    filter: drop-shadow(0 0 6px rgba(255,209,64,.9));
    animation: twinkle 1.3s ease-out forwards;
  }
  @keyframes twinkle {
    0% { transform: translate(-50%,-50%) scale(0.2); opacity: 0; }
    15% { opacity: 1; transform: translate(-50%,-50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%,-64%) scale(0.1); }
  }

  /* Writing canvas (parchment style) */
  .write-wrap{ background:#f7e8c7; border:2px dashed #8b6a3b; border-radius:12px; padding:8px; }
  .write-toolbar{ display:flex; gap:8px; align-items:center; margin-bottom:6px; }
  #writeCanvas{ width:100%; height:180px; background:
      radial-gradient(ellipse at top left, rgba(255,255,255,.6), rgba(255,255,255,0) 60%),
      radial-gradient(ellipse at bottom right, rgba(0,0,0,.06), rgba(0,0,0,0) 60%),
      repeating-linear-gradient(0deg, transparent, transparent 28px, rgba(0,0,0,.04) 29px, transparent 30px);
    border:2px solid #8b6a3b; border-radius:10px; touch-action:none; /* required for pointer events on iOS */
  }
  .write-hidden{ display:none; }

  .good{ color:var(--good); } .bad{ color:var(--bad); }
  .sr-only{ position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
</style>
</head>
<body>
  <header>
    <h1>Raiders of the Lost Letters</h1>
    <div class="tag">Write it, then spell it! Optional practice canvas + ‚Äú‚ùå Mark the Map‚Äù button for submissions.</div>
  </header>

  <main class="wrap grid">
    <!-- Word list panel -->
    <section class="panel grid">
      <label for="listBox"><strong>Word list</strong> (one per line or commas)</label>
      <textarea id="listBox">because
treasure
jungle
adventure
map
whisper
rhythm
friend
school
beautiful</textarea>
      <div class="controls">
        <button id="btnUseList">Use These Words (Shuffle)</button>
        <button id="btnHuntAgain" class="secondary">Hunt Again (Shuffle)</button>
      </div>
    </section>

    <!-- Map -->
    <section class="panel grid">
      <div class="map-box">
        <svg id="map" viewBox="0 0 1000 260" preserveAspectRatio="none" aria-hidden="true">
          <defs>
            <!-- Landmark icon set -->
            <g id="palm">
              <rect x="-2" y="0" width="4" height="22" fill="#6b4a2a"/>
              <path d="M0,0 C-14,4 -10,-6 0,-5 C10,-6 14,4 0,0 Z" fill="#2f7d3b"/>
              <path d="M0,-2 C-10,2 -7,-6 0,-5 C7,-6 10,2 0,-2 Z" fill="#3e9a4a"/>
            </g>
            <g id="pine">
              <rect x="-1.5" y="8" width="3" height="12" fill="#6b4a2a"/>
              <path d="M0,0 L10,12 L-10,12 Z" fill="#2f6b3b"/>
              <path d="M0,-6 L8,4 L-8,4 Z" fill="#3c8d4c"/>
            </g>
            <g id="skull">
              <path d="M0,0 a14,10 0 1,0 0.1,0" fill="#a98e6b"/>
              <circle cx="-5" cy="-3" r="2.4" fill="#2a2115"/>
              <circle cx="5" cy="-3" r="2.4" fill="#2a2115"/>
              <rect x="-1.6" y="1.5" width="3.2" height="5" fill="#2a2115"/>
            </g>
            <g id="compass">
              <circle cx="0" cy="0" r="8" fill="none" stroke="#7a4f21" stroke-width="2"/>
              <path d="M0,-8 L2.4,0 L0,8 L-2.4,0 Z" fill="#caa33a"/>
            </g>
            <g id="fire">
              <path d="M-10,10 l20,0 l-6,4 l-8,0 z" fill="#6b3f1f"/>
              <path d="M0,0 C-6,4 -4,-4 0,-6 C4,-4 6,4 0,0 Z" fill="#ff8a00"/>
              <path d="M0,-2 C-4,2 -3,-3 0,-4 C3,-3 4,2 0,-2 Z" fill="#ffd54a"/>
            </g>
            <g id="rock">
              <path d="M-10,6 L-6,-2 L6,-2 L10,6 Z" fill="#8b7b6d"/>
            </g>
            <g id="barrel">
              <rect x="-6" y="-8" width="12" height="16" rx="2" fill="#7a4f21"/>
              <rect x="-6" y="-5" width="12" height="2" fill="#5a3a19"/>
              <rect x="-6" y="3" width="12" height="2" fill="#5a3a19"/>
            </g>
            <g id="tent">
              <path d="M-12,8 L0,-8 L12,8 Z" fill="#b07d38"/>
              <path d="M0,8 L0,-8" stroke="#8a5f2a" stroke-width="2"/>
            </g>
          </defs>
          <path id="trail" d="M60,210 C160,70 260,240 360,170 S560,90 660,170 820,240 920,170" />
        </svg>

        <!-- Landmarks along trail -->
        <div id="decorLayer"></div>

        <!-- X's -->
        <div id="xLayer"></div>

        <!-- Avatar (explorer) -->
        <svg id="avatar" viewBox="0 0 80 80" aria-hidden="true">
          <ellipse cx="40" cy="22" rx="26" ry="8" fill="#4a3926"/>
          <path d="M28 12 q12-8 24 0 l-4 14 h-16z" fill="#3a2c1e"/>
          <circle cx="40" cy="32" r="10" fill="#f0c799"/>
          <path d="M26 44 h28 l6 22 h-40z" fill="#5b3e24"/>
          <rect x="36" y="44" width="8" height="8" fill="#d9d2c2"/>
          <rect x="24" y="54" width="32" height="4" fill="#3b2a15"/>
          <path d="M28 44 l24 22" stroke="#caa06a" stroke-width="4"/>
        </svg>

        <!-- Treasure chest -->
        <svg id="chest" viewBox="0 0 80 80" aria-hidden="true">
          <rect x="10" y="30" width="60" height="30" rx="4" fill="#6b3f1f" stroke="#2c1b0e" stroke-width="3"/>
          <path d="M10 30 q30-18 60 0 v8 h-60z" fill="#8c5228" stroke="#2c1b0e" stroke-width="3"/>
          <rect x="37" y="40" width="6" height="10" fill="#c99b3b" />
        </svg>

        <!-- Sparkles layer -->
        <div id="sparkles"></div>
      </div>

      <div class="answer-row">
        <label class="sr-only" for="answer">Type the word</label>
        <input id="answer" type="text" placeholder="Type the word" autocomplete="off" />
        <button id="btnMark">‚ùå Mark the Map</button>
      </div>

      <!-- Writing Canvas (default visible) -->
      <section id="writeSection" class="write-wrap">
        <div class="write-toolbar">
          <strong>‚úçÔ∏è Write It</strong>
          <button id="btnToggleWrite" class="secondary">Hide</button>
          <button id="btnUndo" class="secondary">Undo</button>
          <button id="btnClear" class="secondary">Clear</button>
        </div>
        <canvas id="writeCanvas"></canvas>
      </section>

      <div id="feedback"></div>

      <div class="stats">
        <div class="pill">Words: <span id="statTotal">0</span></div>
        <div class="pill">Mastered: <span id="statMastered">0</span></div>
        <div class="pill">Correct: <span id="statCorrect">0</span></div>
        <div class="pill">Wrong: <span id="statWrong">0</span></div>
        <div class="pill">Repeats (score): <span id="statRepeats">0</span></div>
        <div class="pill">Best: <span id="statBest">‚Äî</span></div>
      </div>

      <div class="controls">
        <button id="btnHear" class="secondary">üîä Hear Word</button>
        <button id="btnWriteToggleTop" class="secondary">‚úçÔ∏è Write It</button>
      </div>
    </section>
  </main>

  <!-- Confetti layer -->
  <div id="confetti" class="confetti"></div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const normalize = s => s.toLowerCase().trim().replace(/[^a-z']/g,'');

  // Shuffle
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  // ----- SFX -----
  let audioCtx;
  function ctx(){ return audioCtx || (audioCtx = new (window.AudioContext||window.webkitAudioContext)()); }
  function tone(f=440,d=0.12,type='sine',vol=0.25){
    const ac = ctx();
    const o = ac.createOscillator(); const g = ac.createGain();
    o.type=type; o.frequency.value=f; g.gain.value=vol;
    o.connect(g); g.connect(ac.destination); o.start(); setTimeout(()=>o.stop(), d*1000);
  }
  function noise(dur=0.2, vol=0.2, loop=false){
    const ac = ctx();
    const buffer = ac.createBuffer(1, Math.max(1, ac.sampleRate*dur), ac.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1); }
    const src = ac.createBufferSource(); src.buffer = buffer; src.loop = loop;
    const bp = ac.createBiquadFilter(); bp.type='highpass'; bp.frequency.value=1200; // scratchy feel
    const g = ac.createGain(); g.gain.value = vol;
    src.connect(bp); bp.connect(g); g.connect(ac.destination);
    return {src, g};
  }
  const sfx = {
    coin(){ tone(900,.08,'square',.22); setTimeout(()=>tone(1350,.08,'square',.2),60); },
    whoosh(){ tone(220,.05,'sine',.12); setTimeout(()=>tone(440,.06,'sine',.14),60); setTimeout(()=>tone(660,.08,'sine',.16),120); },
    drum(){ const {src,g}=noise(.12,.22,false); src.start(); setTimeout(()=>{ try{src.stop();}catch(e){}},120); },
    treasure(){
      const seq = [392,523,659,784,988,1175,1319];
      seq.forEach((f,i)=>setTimeout(()=>tone(f,.14,'triangle',.25), i*120));
      setTimeout(()=>{ const {src,g}=noise(.25,.15,false); src.start(); setTimeout(()=>{ try{src.stop();}catch(e){}},250); }, seq.length*120 + 80);
    },
    penLoop: null,
    startPen(){
      if(!this.penLoop){
        const {src,g} = noise(0.3, 0.0, true);
        this.penLoop = {src, g};
        try{ src.start(); }catch(e){}
      }
      // fade in
      const ac = ctx();
      this.penLoop.g.gain.cancelScheduledValues(ac.currentTime);
      this.penLoop.g.gain.setTargetAtTime(0.18, ac.currentTime, 0.02);
    },
    stopPen(){
      if(!this.penLoop) return;
      const ac = ctx();
      this.penLoop.g.gain.cancelScheduledValues(ac.currentTime);
      this.penLoop.g.gain.setTargetAtTime(0.0, ac.currentTime, 0.05);
    }
  };

  function maybeRandomSFX(){
    const r = Math.random();
    if(r < 0.25) sfx.coin();
    else if(r < 0.45) sfx.whoosh();
    else if(r < 0.6) sfx.drum();
  }

  function speak(text){
    try{
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.95; u.pitch = 1.0; u.lang = 'en-US';
      window.speechSynthesis.speak(u);
    }catch(e){}
  }

  function confettiBurst(n=60){
    const layer = $('confetti');
    for(let i=0;i<n;i++){
      const el = document.createElement('i');
      el.style.left = Math.random()*100 + 'vw';
      el.style.background = ['gold','#d4af37','#ffd54a','#f5c36b'][i%4];
      el.style.animationDelay = (Math.random()*0.25)+'s';
      el.style.transform = `translateY(${Math.random()*-40}px) rotate(${Math.random()*180}deg)`;
      layer.appendChild(el);
      setTimeout(()=>layer.removeChild(el), 1600);
    }
  }

  // --- Coordinate scaling to fix iOS alignment ---
  const VIEW_W = 1000, VIEW_H = 260;
  function svgScale(){
    const svg = document.getElementById('map');
    const w = svg.clientWidth || VIEW_W;
    const h = svg.clientHeight || VIEW_H;
    return { sx: w/VIEW_W, sy: h/VIEW_H };
  }

  // Map / Path helpers
  let path, pathLength=1;
  function initPath(){
    path = document.getElementById('trail');
    pathLength = path.getTotalLength ? path.getTotalLength() : 1000;
    placeAtPercent($('chest'), 0.995); // chest at end
  }
  function pointAt(p){
    p = Math.max(0, Math.min(1, p));
    const d = p * pathLength;
    return path.getPointAtLength(d);
  }
  function placeAtPercent(el, p){
    const pt = pointAt(p);
    const {sx, sy} = svgScale();
    el.style.left = (pt.x * sx) + 'px';
    el.style.top  = (pt.y * sy) + 'px';
  }
  function setAvatarAtPercent(p){ placeAtPercent($('avatar'), p); }

  // X's
  function drawXMarks(n){
    const layer = $('xLayer'); layer.innerHTML='';
    if(n <= 0) return;
    const {sx, sy} = svgScale();
    for(let i=1;i<=n;i++){
      const p = i/n;
      const pt = pointAt(p);
      const x = document.createElement('div');
      x.className = 'x';
      x.style.left = (pt.x * sx) + 'px';
      x.style.top  = (pt.y * sy) + 'px';
      layer.appendChild(x);
    }
  }

  // landmark size: ~25% of avatar height, +20% globally
  function landmarkSizePx(){
    const avatar = document.getElementById('avatar');
    const h = avatar.clientHeight || 72;
    let base = Math.round(0.25 * h);
    base = Math.round(base * 1.2); // +20%
    const w = document.querySelector('.map-box').clientWidth || 800;
    if (w > 1100) base = Math.min(base + 4, Math.round(0.33 * h));
    return Math.max(14, base);
  }

  // Helpers: tangent/normal in SVG space
  function tangentAt(p){
    const delta = 0.002;
    const p1 = pointAt(Math.max(0, p - delta));
    const p2 = pointAt(Math.min(1, p + delta));
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.max(1e-6, Math.hypot(dx, dy));
    return { tx: dx/len, ty: dy/len };
  }
  function normalAt(p){
    const {tx, ty} = tangentAt(p);
    return { nx: -ty, ny: tx };
  }

  // Random landmarks along segments between X's, no adjacent repeats, rotated ¬±18¬∞
  function drawRandomLandmarks(n){
    const layer = $('decorLayer'); layer.innerHTML = '';
    const svgNS = "http://www.w3.org/2000/svg";
    const iconIds = ['palm','pine','skull','fire','compass','rock','barrel','tent'];
    const size = landmarkSizePx();
    const {sx, sy} = svgScale();

    const segments = Math.max(1, n);
    let lastId = null;
    for(let i=0;i<segments;i++){
      const add = Math.random() < 0.75 ? 1 : 0;
      for(let k=0;k<add;k++){
        // choose a type different from lastId
        let id = iconIds[Math.floor(Math.random()*iconIds.length)];
        if (id === lastId) {
          const others = iconIds.filter(x => x !== lastId);
          id = others[Math.floor(Math.random()*others.length)];
        }
        lastId = id;

        // place between i/n and (i+1)/n, away from X's
        const startP = i/n;
        const endP   = Math.min(1, (i+1)/n);
        const p = startP + 0.18*(endP-startP) + Math.random() * 0.46*(endP - startP);
        const base = pointAt(p);
        const {nx, ny} = normalAt(p);

        // perpendicular offset so it never sits on the trail
        const side = Math.random() < 0.5 ? -1 : 1;
        const mapW = document.querySelector('.map-box').clientWidth || 800;
        const distBase = (mapW <= 430) ? 34 : (mapW > 900 ? 34 : 30);
        const dist = distBase + Math.random()*14; // 30‚Äì48px
        const dx = nx * dist * side;
        const dy = ny * dist * side;

        const el = document.createElementNS(svgNS, 'svg');
        el.setAttribute('viewBox','-25 -25 50 50');
        el.style.position = 'absolute';
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        const rot = (Math.random()*36 - 18); // ¬±18¬∞
        el.style.left = ((base.x + dx) * sx) + 'px';
        el.style.top  = ((base.y + dy) * sy) + 'px';
        el.style.transform = `translate(-50%,-50%) rotate(${rot}deg)`;
        el.style.opacity = 0.98;
        el.innerHTML = `<use href="#${id}"></use>`;
        layer.appendChild(el);
      }
    }
  }

  // Chest sparkle
  function chestSparkle(){
    const layer = $('sparkles');
    const chest = $('chest');
    const rect = chest.getBoundingClientRect();
    const mapRect = chest.parentElement.getBoundingClientRect();

    function spawnOne(){
      const s = document.createElement('div');
      s.className = 'sparkle';
      const cx = rect.left - mapRect.left + rect.width/2;
      const cy = rect.top - mapRect.top + rect.height/2;
      const r = 48 * Math.random();
      const angle = Math.random()*Math.PI*2;
      s.style.left = (cx + r*Math.cos(angle)) + 'px';
      s.style.top  = (cy + r*Math.sin(angle)) + 'px';
      s.style.animationDelay = (Math.random()*0.35)+'s';
      layer.appendChild(s);
      setTimeout(()=>{ if(s.parentNode) s.parentNode.removeChild(s); }, 1500);
    }

    for(let i=0;i<20;i++) spawnOne();
    setTimeout(()=>{ for(let i=0;i<16;i++) spawnOne(); }, 300);
  }

  // =====================
  // Writing Canvas logic
  // =====================
  const canvas = $('writeCanvas');
  const writeSection = $('writeSection');
  const btnToggleWrite = $('btnToggleWrite');
  const btnWriteToggleTop = $('btnWriteToggleTop');
  const btnUndo = $('btnUndo');
  const btnClear = $('btnClear');

  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let ctx2d = canvas.getContext('2d');
  let drawing = false;
  let strokes = []; // array of stroke arrays: [{x,y}, ...]
  let currentStroke = [];

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(140, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx2d.setTransform(dpr,0,0,dpr,0,0);
    redraw();
  }

  function redraw(){
    // clear
    ctx2d.clearRect(0,0,canvas.width,canvas.height);
    ctx2d.save();
    ctx2d.scale(dpr,dpr);
    // draw strokes
    ctx2d.lineCap = 'round'; ctx2d.lineJoin='round';
    ctx2d.lineWidth = 4; ctx2d.strokeStyle = '#3b2a15';
    for(const s of strokes){
      if(s.length<2) continue;
      ctx2d.beginPath();
      ctx2d.moveTo(s[0].x, s[0].y);
      for(let i=1;i<s.length;i++){ ctx2d.lineTo(s[i].x, s[i].y); }
      ctx2d.stroke();
    }
    ctx2d.restore();
  }

  function getPos(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX ?? (e.touches && e.touches[0].clientX)) - r.left;
    const y = (e.clientY ?? (e.touches && e.touches[0].clientY)) - r.top;
    return {x, y};
  }

  function startDraw(e){
    try{ ctx().resume(); }catch(_){}
    drawing = true;
    currentStroke = [];
    strokes.push(currentStroke);
    const p = getPos(e);
    currentStroke.push(p);
    sfx.startPen();
  }
  function moveDraw(e){
    if(!drawing) return;
    const p = getPos(e);
    currentStroke.push(p);
    redraw();
  }
  function endDraw(){
    if(!drawing) return;
    drawing = false;
    sfx.stopPen();
  }

  // Pointer events
  canvas.addEventListener('pointerdown', (e)=>{ canvas.setPointerCapture(e.pointerId); startDraw(e); });
  canvas.addEventListener('pointermove', moveDraw);
  canvas.addEventListener('pointerup', endDraw);
  canvas.addEventListener('pointercancel', endDraw);
  canvas.addEventListener('pointerleave', endDraw);

  // Toolbar actions
  btnUndo.addEventListener('click', ()=>{ strokes.pop(); redraw(); });
  btnClear.addEventListener('click', ()=>{ strokes = []; redraw(); sfx.drum(); });

  function toggleWrite(){
    const hidden = writeSection.classList.toggle('write-hidden');
    btnToggleWrite.textContent = hidden ? 'Show' : 'Hide';
  }
  btnToggleWrite.addEventListener('click', toggleWrite);
  btnWriteToggleTop.addEventListener('click', toggleWrite);

  // Initial canvas sizing
  new ResizeObserver(()=>resizeCanvas()).observe(canvas);
  window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 250));

  // =====================

  // Game state
  let baseList = [];
  let queue = [];
  let total = 0;
  let current = null;
  let stats = {correct:0, wrong:0, attempts:0};
  let stepIndex = 0; // progress only on correct
  let speakLock = false;

  function repeats(){ return Math.max(0, stats.attempts - total); }

  function parseList(text){
    const parts = text.split(/[,\n]+/).map(s=>s.trim()).filter(Boolean);
    const seen = new Set(); const out=[];
    for(const raw of parts){
      const key = raw.toLowerCase().trim();
      if(!key || seen.has(key)) continue;
      seen.add(key); out.push(raw);
    }
    return out;
  }

  function updateStats(){
    $('statTotal').textContent = total;
    $('statMastered').textContent = queue.filter(w=>w.mastered).length;
    $('statCorrect').textContent = stats.correct;
    $('statWrong').textContent = stats.wrong;
    $('statRepeats').textContent = repeats();
    const best = localStorage.getItem('treasure_best_repeats');
    $('statBest').textContent = (best===null ? '‚Äî' : best);
  }

  function startRound(reshuffle=true){
    initPath();
    const list = reshuffle ? shuffle(baseList) : baseList.slice();
    queue = list.map(raw => ({raw, key:normalize(raw), mastered:false}));
    total = queue.length;
    stats = {correct:0, wrong:0, attempts:0};
    stepIndex = 0;
    $('answer').value = '';
    $('feedback').textContent='';
    $('feedback').className='';
    drawXMarks(total);
    drawRandomLandmarks(total);
    updateStats();
    setAvatarAtPercent(0);
    next(true);
  }

  function next(autoSpeak=false){
    while(queue.length && queue[0].mastered) queue.shift();
    if(queue.length === 0){ return finish(); }
    current = queue[0];
    if(autoSpeak && !speakLock){
      speakLock = true;
      speak(current.raw);
      setTimeout(()=>{ speakLock=false; }, 500);
    }
    $('answer').focus();
  }

  function submit(){
    if(!current) return;
    const val = normalize($('answer').value);
    if(!val) return;
    stats.attempts++;

    if(val === current.key){
      current.mastered = true;
      stats.correct++;
      $('feedback').textContent = `‚úÖ Correct: ${current.raw}`;
      $('feedback').className = 'good';
      maybeRandomSFX();

      // Advance one X (progress only on correct)
      stepIndex = Math.min(total, stepIndex + 1);
      setAvatarAtPercent(stepIndex/total);

      queue.shift();
      updateStats();
      $('answer').value = '';
      // clear writing canvas for next word
      strokes = []; redraw();
      next(true);

    } else {
      stats.wrong++;
      $('feedback').textContent = `‚ùå Oops. The word was ‚Äú${current.raw}‚Äù. We'll try it again soon.`;
      $('feedback').className = 'bad';
      sfx.drum();

      // No backtracking; stay on same X
      queue.shift();
      const insertAt = Math.min(3, queue.length);
      queue.splice(insertAt, 0, current);

      updateStats();
      $('answer').value = '';
      // keep writing for another try
      next(true);
    }
  }

  function finish(){
    setAvatarAtPercent(1);
    const score = repeats();
    const key='treasure_best_repeats';
    const currBest = localStorage.getItem(key);
    if(currBest===null || score < Number(currBest)){ localStorage.setItem(key, String(score)); }
    $('statBest').textContent = localStorage.getItem(key);
    $('feedback').innerHTML = `üéâ You found the treasure! Repeats (score): <b>${score}</b>. Best: <b>${localStorage.getItem(key)}</b>.`;
    confettiBurst(80);
    sfx.treasure();
    chestSparkle();
  }

  // Events
  $('btnUseList').addEventListener('click', ()=>{
    const text = $('listBox').value;
    const parsed = parseList(text);
    if(parsed.length === 0){ alert('Please enter at least one word.'); return; }
    baseList = parsed;
    startRound(true); // shuffle
  });
  $('btnHuntAgain').addEventListener('click', ()=>{
    if(baseList.length === 0){ alert('Paste a word list first.'); return; }
    startRound(true); // shuffle & new random landmarks
  });
  $('btnHear').addEventListener('click', ()=>{ if(current){ try{ ctx().resume(); }catch(e){} speak(current.raw); } });
  $('answer').addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ submit(); }});
  $('btnMark').addEventListener('click', submit);

  // Initialize best
  const best = localStorage.getItem('treasure_best_repeats');
  $('statBest').textContent = (best===null ? '‚Äî' : best);

  // Recompute positions on resize/rotation to keep iOS aligned
  window.addEventListener('resize', ()=>{
    drawXMarks(total || 0);
    drawRandomLandmarks(total || 0);
    setAvatarAtPercent(stepIndex/(total||1));
    placeAtPercent($('chest'), 0.995);
  });

  // Init path after DOM ready
  function initPath(){
    path = document.getElementById('trail');
    pathLength = path.getTotalLength ? path.getTotalLength() : 1000;
    placeAtPercent($('chest'), 0.995);
  }
})();
</script>
</body>
</html>
