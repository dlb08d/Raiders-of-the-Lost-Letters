
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Raiders of the Lost Letters</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Arial, sans-serif;
    background: #f4e2c2;
    margin: 0;
    padding: 0 0 30px 0;
    text-align: center;
    color: #3b2a14;
  }
  h1 {
    color: #8b4513;
    text-shadow: 1px 1px #fff;
    margin: 16px 0 6px;
  }
  .muted { color:#6b5432; font-size:14px; margin-bottom: 8px; }
  #map-container {
    position: relative;
    width: min(960px, 92%);
    height: 170px; /* Taller map to avoid clipping */
    margin: 14px auto 10px;
    background: linear-gradient(180deg,#d9c08c,#caae74);
    border: 5px solid #8b4513;
    border-radius: 16px;
    overflow: hidden;
  }
  /* Simple dashed trail */
  #trail {
    position:absolute; inset:0;
  }
  #x-marks {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 26px;
    pointer-events: none;
    font-size: 22px;
    color: #7a4f21;
    text-shadow: 0 1px 0 #f6e8c8;
  }
  #progress-character {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translate(-50%, -50%); /* keep centered vertically */
    width: 64px;
    height: 64px;
    transition: left 0.45s ease-in-out, top 0.2s ease;
    filter: drop-shadow(0 6px 6px rgba(0,0,0,.25));
  }
  /* Controls */
  .controls { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin: 10px 0; }
  button {
    padding: 10px 14px;
    font-size: 15px;
    cursor: pointer;
    background-color: #d4af37;
    border: none;
    border-radius: 8px;
    color: #1f1408;
  }
  button.secondary{ background:#c59f2f; }
  input[type="text"] {
    font-size: 18px;
    padding: 8px 10px;
    width: min(640px, 92%);
    margin-top: 6px;
    border-radius: 8px;
    border: 2px solid #caa86a;
    outline: none;
  }
  #feedback { font-size: 16px; min-height: 22px; margin-top: 8px; }
  .good { color:#1f8b45; }
  .bad { color:#c0392b; }
  .stats { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin: 6px 0 0; font-size:14px; color:#5a4123; }
  .pill{ padding:4px 8px; border:1px solid #caa86a; border-radius:999px; background:#f7e8c7; }
  .small{ font-size:13px; }
  .sr-only{ position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
</style>
</head>
<body>
  <h1>Raiders of the Lost Letters</h1>
  <div class="muted small">Each ‚ùå is a word. Correct = move forward. Wrong = step back. Finish when every word is spelled correctly.</div>

  <div id="map-container">
    <!-- simple SVG curve as a dashed trail -->
    <svg id="trail" viewBox="0 0 1000 220" preserveAspectRatio="none" aria-hidden="true">
      <path d="M60,160 C150,60 260,200 340,120 S520,40 600,120 760,200 880,120"
            stroke="#7a4f21" stroke-width="8" fill="none" stroke-linecap="round" stroke-dasharray="14 16"/>
    </svg>
    <div id="x-marks"></div>
    <!-- Simple explorer avatar as inline SVG to avoid external images -->
    <svg id="progress-character" viewBox="0 0 80 80" aria-hidden="true">
      <!-- hat brim -->
      <ellipse cx="40" cy="22" rx="26" ry="8" fill="#4a3926"/>
      <!-- hat crown -->
      <path d="M28 12 q12-8 24 0 l-4 14 h-16z" fill="#3a2c1e"/>
      <!-- head -->
      <circle cx="40" cy="32" r="10" fill="#f0c799"/>
      <!-- body -->
      <path d="M26 44 h28 l6 22 h-40z" fill="#5b3e24"/>
      <rect x="36" y="44" width="8" height="8" fill="#d9d2c2"/>
      <rect x="24" y="54" width="32" height="4" fill="#3b2a15"/>
      <!-- satchel -->
      <path d="M28 44 l24 22" stroke="#caa06a" stroke-width="4"/>
    </svg>
  </div>

  <div class="controls">
    <button id="btnStart">Start / New List</button>
    <button id="btnHuntAgain" class="secondary">Hunt Again</button>
    <button id="btnHear" class="secondary">üîä Hear Word</button>
  </div>

  <label class="sr-only" for="word-input">Type the word</label>
  <input id="word-input" type="text" placeholder="Type the word and press Enter" autocomplete="off" />
  <div id="feedback"></div>

  <div class="stats">
    <div class="pill">Words: <span id="statTotal">0</span></div>
    <div class="pill">Mastered: <span id="statMastered">0</span></div>
    <div class="pill">Correct: <span id="statCorrect">0</span></div>
    <div class="pill">Wrong: <span id="statWrong">0</span></div>
    <div class="pill">Repeats (score): <span id="statRepeats">0</span></div>
    <div class="pill">Best: <span id="statBest">‚Äî</span></div>
  </div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);

  // Shuffle (Fisher-Yates)
  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  const normalize = s => s.toLowerCase().trim().replace(/[^a-z']/g,'');
  function speak(text){
    try{
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.95; u.pitch = 1.0; u.lang = 'en-US';
      window.speechSynthesis.speak(u);
    }catch(e){ /* ignore if not supported */ }
  }

  // State
  let originalList = [];        // strings
  let queue = [];               // {raw, key, mastered:false}
  let current = null;
  let total = 0;
  let stats = {correct:0, wrong:0, attempts:0};
  let positionIndex = 0;        // for map progress (0..total)
  let lockPrompt = false;       // prevent double-speaking / overlapping

  function repeats(){ return Math.max(0, stats.attempts - total); }

  function parseInputList(s){
    const parts = s.split(/[,\n]+/).map(w=>w.trim()).filter(Boolean);
    const seen = new Set();
    const list = [];
    for(const raw of parts){
      const key = normalize(raw);
      if(!key || seen.has(key)) continue;
      seen.add(key);
      list.push(raw);
    }
    return list;
  }

  function setupXMarks(n){
    const layer = $('x-marks');
    layer.innerHTML = '';
    if(n <= 0) return;
    for(let i=0;i<n;i++){
      const span = document.createElement('span');
      span.textContent = '‚ùå';
      layer.appendChild(span);
    }
  }

  function placeCharacterByProgress(idx){ // idx 0..total
    const map = $('map-container');
    const char = $('progress-character');
    const w = map.clientWidth;
    const charW = char.clientWidth || 64;
    const steps = Math.max(1,total); // avoid div by zero
    const step = (w - 52) / steps; // 52 padding to keep inside border
    const left = 26 + (idx * step); // 26 left padding
    char.style.left = left + 'px';
  }

  function updateStats(){
    $('statTotal').textContent = total;
    $('statMastered').textContent = queue.filter(w=>w.mastered).length;
    $('statCorrect').textContent = stats.correct;
    $('statWrong').textContent = stats.wrong;
    $('statRepeats').textContent = repeats();
  }

  function startNewList(){
    const input = prompt("Enter your spelling words (comma or new line separated):");
    if(!input) return;
    originalList = parseInputList(input);
    if(originalList.length === 0){ alert("Please enter at least one word."); return; }
    startRound(true);
  }

  function startRound(reshuffle){
    // create queue of objects
    const base = reshuffle ? shuffle(originalList) : originalList.slice();
    queue = base.map(raw=>({raw, key:normalize(raw), mastered:false}));
    total = queue.length;
    stats = {correct:0, wrong:0, attempts:0};
    positionIndex = 0;
    current = null;
    $('word-input').value='';
    $('feedback').textContent='';
    $('feedback').className='';
    const best = localStorage.getItem('treasure_best_repeats');
    $('statBest').textContent = (best===null ? '‚Äî' : best);
    setupXMarks(total);
    updateStats();
    placeCharacterByProgress(0);
    next(true);
  }

  function next(autoSpeak){
    // consume already-mastered items
    while(queue.length && queue[0].mastered) queue.shift();
    if(queue.length === 0){ return finish(); }
    current = queue[0];
    if(autoSpeak && !lockPrompt){
      lockPrompt = true;
      speak(current.raw);
      setTimeout(()=>{ lockPrompt = false; }, 600); // brief lock to avoid overlaps
    }
    $('word-input').focus();
  }

  function submit(){
    if(!current) return;
    const val = normalize($('word-input').value);
    if(!val) return;
    stats.attempts++;

    if(val === current.key){
      current.mastered = true;
      stats.correct++;
      $('feedback').textContent = `‚úÖ Correct: ${current.raw}`;
      $('feedback').className='good';

      // forward step toward treasure
      positionIndex = Math.min(positionIndex + 1, total);
      placeCharacterByProgress(positionIndex);

      // remove mastered from front
      queue.shift();
      updateStats();
      $('word-input').value='';

      // speak next word once
      next(true);

    } else {
      stats.wrong++;
      $('feedback').textContent = `‚ùå Oops. The word was ‚Äú${current.raw}‚Äù. We'll try it again soon.`;
      $('feedback').className='bad';

      // back a step
      positionIndex = Math.max(0, positionIndex - 1);
      placeCharacterByProgress(positionIndex);

      // reinsert current a few spots later so it repeats
      queue.shift();
      const insertAt = Math.min(3, queue.length);
      queue.splice(insertAt, 0, current);

      updateStats();
      $('word-input').value='';

      // IMPORTANT: do NOT speak the missed word again immediately.
      // Only speak the new current word after we've moved on.
      next(true);
    }
  }

  function finish(){
    // All words mastered
    placeCharacterByProgress(total);
    const score = repeats();
    const key = 'treasure_best_repeats';
    const currBest = localStorage.getItem(key);
    if (currBest === null || score < Number(currBest)) {
      localStorage.setItem(key, String(score));
    }
    const best = localStorage.getItem(key);
    $('statBest').textContent = best;
    $('feedback').innerHTML = `üéâ You found the treasure! Repeats (score): <b>${score}</b>. Best: <b>${best}</b>.`;
  }

  // Events
  $('btnStart').addEventListener('click', ()=>startNewList());
  $('btnHuntAgain').addEventListener('click', ()=>{
    if(originalList.length === 0){ startNewList(); }
    else { startRound(true); } // reshuffle for a fresh hunt
  });
  $('btnHear').addEventListener('click', ()=>{ if(current) speak(current.raw); });
  $('word-input').addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ submit(); }});

  // Initial best load
  const best = localStorage.getItem('treasure_best_repeats');
  $('statBest').textContent = (best===null ? '‚Äî' : best);
})();
</script>
</body>
</html>
